#================================================================================
# Rogo.rogue
#================================================================================

$define VERSION "2.0"
$define DATE    "July 15, 2022"

$include CreateBuildfile
$include CreateGitIgnore
$include CreateProjectSource

#$ ROGUEC       = roguec
#$ ROGUEC_ARGS  = --whatever
#$ CC           = gcc -Wall
#$ CC_ARGS      = -a -b -c
#$ LINK         = -lalpha -lbeta    # Includes these additional flags when linking the buildfile.
#$ LINK_LIBS    = true              # Links following LIBRARIES with this Build file
#$ LINK_LIBS    = false             # Linking turned off for following LIBRARIES
#$ LIBRARIES    = name
#$ LIBRARIES    = name(<package-name>)
#$ LIBRARIES    = name(OPTIONS...)           # 'name' is the default package name etc.
#                 OPTIONS                    EXAMPLE
#                 exe:<which-name>           exe:"wget"
#                 exists-cmd:<exists-cmd>    exists-cmd:"which wget"
#                 flags:<library-flags>      flags:"-I/opt/homebrew/opt/freetype/include/freetype2"
#                 info:<info-name>           info:freetype2
#                 info-cmd:<get-info-cmd>    info-cmd:"pkg-config --cflags freetype2"
#                 install:<install-name>     install:libfreetype6-dev
#                 install-cmd:<install-cmd>  install:"sudo apt-get install libfreetype6-dev"
#                 package:<package-name>     package:libjpeg
#$ DEPENDENCIES = Library/Rogue/**/*.rogue

# Build.rogue source replacements - the libraries should also be declared in #$ LIBRARIES:
#   $LIBRARY_FLAGS(lib1,lib2) -> -Ipath/to/lib1/include -Lpath/to/lib1/library -I ...

Rogo

class Rogo [singleton]
  PROPERTIES
    buildfiles        = Buildfiles()
    resolved_args     = String[]
    project_folder    : File
    rogo_folder       : File
    cache_file        : File
    cache             : Value
    config            : Value
    is_cache_modified : Logical
    link_libraries   = false
    syntax_info      = [String:String]
    description_info = [String:String]

    package_manager         = "apt"  # Linux
    package_manager_install = "sudo apt-get install"
    package_manager_list    : String

    found_description_routine : Logical

  METHODS
    method init
      local args = System.command_line_arguments
      if (args.count == 1 and args.first == "--version")
        println VERSION
        println "$ by Abe Pralle"(DATE)
        System.exit
      endIf

      local should_create_buildfile = false
      local build_filepath : String

      forEach (arg in args)
        if (arg == "--build" or arg.begins_with("--build="))
          local cur_buildfile = arg.after_first( '=' )
          if (cur_buildfile.count == 0)
            Global.error.println ''ERROR: expected filename after "--build=".''
            System.exit 1
          endIf
          if (not File(cur_buildfile).exists)
            if (File(cur_buildfile + ".rogue").exists)
              cur_buildfile += ".rogue"
            else
              Global.error.println ''ERROR: no such file "$".'' (cur_buildfile)
              System.exit 1
            endIf
          endIf
          build_filepath = File(cur_buildfile).abs
          buildfiles.add( build_filepath )

        else
          if (arg == "--create") should_create_buildfile = true
          else                   resolved_args.add( arg )
        endIf
      endForEach

      if (build_filepath)
        project_folder = File(build_filepath)
        if (not project_folder.is_folder)
          project_folder .= parent
        endIf
        rogo_folder = project_folder/".rogo"
        local pwd = (File(".").abs/"").filepath
        if (rogo_folder.filepath.begins_with(pwd)) rogo_folder = File( rogo_folder.filepath.unleft(pwd.count) )
      else
        project_folder = File(".")
        rogo_folder = File(".rogo")
      endIf

      # These add()s only succeed for files that actually exist.
      buildfiles.add( project_folder/"Build.rogue" )
      buildfiles.add( project_folder/"BuildCore.rogue" )
      buildfiles.add( project_folder/"BuildLocal.rogue" )

      if (not buildfiles.count)
        if (should_create_buildfile)
          CreateBuildfile( resolved_args )
          resolved_args.clear
        else
          local w = Console.width.or_smaller( 80 )
          Global.error.println "=" * w
          local mesg = "ROGO ERROR\n\n"
          mesg += @|No standard build file exists (Build.rogue, BuildCore.rogue, BuildLocal.rogue)
          mesg += @| and no alternate specified with --build=<filename>.
                   |
                   |
          mesg += @|Type 'rogo --create [options]' to create Build.rogue with a default framework.
                   |
                   |OPTIONS
                   |  --project=ProjectName
                   |    Creates additional starter framework for the specified ProjectName.
                   |
                   |  --bitmap
                   |    Links Build.rogue and the starter project (if --project is specified) with
                   |    libpng and libjpeg libraries.
                   |
                   |If no options are specified then only Build.rogue is created.
          Global.error.println( mesg.word_wrapped(w) )
          Global.error.println "=" * w
          Global.error.println
          System.exit 1
        endIf
      endIf

      rogo_folder.create_folder
      cache_file = "$/Cache-$.json" (rogo_folder,System.os)
      config     = @{ roguec:"roguec", filepath:cache_file.filepath }
      cache      = JSON.load( cache_file )
      if (not cache.is_table) cache = @{}

      if (System.is_windows)
        config//cc = "cl /EHsc /nologo"
      else
        config//cc = "gcc -Wall"
      endIf

      local base_name = rogo_folder/"Build"
      local exe       = base_name
      if (System.is_windows) exe += ".exe"           # .rogo/Build.exe
      else                   exe += "-" + System.os  # .rogo/Build-macOS (etc.)

      configure_os

      local needs_recompile = buildfiles.any_newer_than( exe )

      block
        # Process DEPENDENCIES
        local dependencies = Set<<String>>()
        collect_dependencies( File(forEach in buildfiles), dependencies )

        forEach (pattern in dependencies.values)
          local listing = File( pattern ).listing( &files )
          forEach (dependency in listing)
            if (File(dependency).filename.begins_with("Build") and not buildfiles.contains(dependency))
              collect_directives( File(dependency), dependencies )
            endIf
          endForEach
        endForEach

        forEach (pattern in dependencies.values)
          local listing = File( pattern ).listing( &files )
          forEach (dependency in listing)
            if (File(dependency).is_newer_than(exe))
              needs_recompile = true
              escapeBlock
            endIf
          endForEach
        endForEach
      endBlock

      if (needs_recompile)
        println "Recompiling $..." (File(buildfiles.first).filename)

        # Collect info for config
        collect_directives( File(forEach in buildfiles) )

        # Select LIBRARIES(macOS), LIBRARIES(Linux), LIBRARIES(Linux-apt) etc. based on the OS
        # and package manager and merge into to LIBRARIES, etc.
        local os_arg = "($)" (System.os.to_lowercase)
        local os_arg_plus_package_manager = "($-$)" (System.os.to_lowercase,package_manager)
        forEach (key in config.keys)
          if (key.contains(os_arg) or key.contains(os_arg_plus_package_manager))
            local generic_key = key.before_first('(')
            if (config.contains(generic_key) and generic_key != "cc" and generic_key != "roguec")
              # Merge specialized-platform keys with generic keys
              if (generic_key == "libraries")
                # Overwrite same-name libraries
                local table = @{}
                forEach (item in config[generic_key]) table[item//name] = item
                forEach (item in config[key])         table[item//name] = item
                config[ generic_key ] = table.values
              else
                # Append specialized keys to end of generic key string
                config[ generic_key ] += " " + config[key]
              endIf
            else
              config[ generic_key ] = config[ key ]
            endIf
          endIf
        endForEach

        # Now that we have the config info, rewriting to handle $+LIBRARY(name) etc. Places copies in .rogo/
        scan_autodoc( File(forEach in buildfiles) )
        forEach (file at index in buildfiles)
          scan_and_rewrite( File(file), &write_autodoc=(index==0) )
        endForEach

        local roguec = config//roguec
        if (not File(roguec).exists) roguec = "r2"  # use system default
        local roguec_args = config//roguec_args->String
        local cmd =  "$ --target=C++,Console,$" (roguec,System.os)
        forEach (filepath in buildfiles)
          cmd += " " + (rogo_folder/File(filepath).filename).esc
        endForEach
        cmd += " --api --debug --main --output=$" (base_name)
        cmd .= appending( roguec_args )
        println cmd

        if (0 != System.run(cmd))
          Global.error.println "ERROR compiling $." (rogo_folder)
          System.exit 1
        endIf

        cmd = config//cc->String
        if (config//cc_args) cmd += " " + config//cc_args
        cmd += " $.c"(base_name)

        forEach (library in config//libraries)
          install_library( library )
          if (library//link_libs)
            cmd += " $" (library_flags(library))
          endIf
        endForEach

        cmd += " $$" (which{System.is_windows:"/Fe"||"-o "},exe)
        cmd .= appending( config//link )

        if (System.is_linux) cmd += " -lm"

        println cmd
        if (0 != System.run(cmd)) System.exit( 1 )
        File( File(exe).filename.before_last(".exe") + ".obj" ).delete
      endIf

      local exit_code = System.run( ''$ $'' (exe,resolved_args.map<<String>>( (arg)=>Rogo.prep_arg(arg) ).join(" ")) )
      System.exit( exit_code )

    method prep_arg( arg:String )->String
      # Quotes and escapes string if necessary
      if (not (arg.contains(' ') or arg.contains('"') or arg.contains('\\'))) return arg
      local quoted = String()
      quoted.print( '"' )
      forEach (ch in arg)
        which (ch)
          case '"':  quoted.print( "\\\"" )
          case '\\': quoted.print( "\\\\" )
          others:    quoted.print( ch )
        endWhich
      endForEach
      quoted.print( '"' )
      return quoted

    method require_command_line
      if (System.env["IDE"])
        throw Error( "$:$: error:Run 'make $' from the command line to install necessary libraries."...
        ($sourceFilepath,$sourceLine,which{System.env["TARGET"]||""}.to_lowercase) )
      endIf

    method save_cache
      is_cache_modified = false
      cache_file.save( cache.to_json(&formatted) )

    method configure_os
      if (System.is_macos)     configure_macos
      elseIf (System.is_linux) configure_linux

    method configure_macos
      if (0 != System.run("which brew > /dev/null 2>&1"))
        require_command_line
        if (Console.input( "\nHomebrew must be installed.  Install now (y/n)? " ).to_lowercase.begins_with('y'))
          local cmd = @|/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
          println cmd
          if (0 != System.run(cmd))
            throw Error( "Failed to install Homebrew." )
          endIf
        else
          throw Error( "Missing required dependency 'brew' (Homebrew)." )
        endIf
      endIf

      if (0 != System.run("which pkg-config > /dev/null 2>&1"))
        require_command_line
        if (Console.input( "pkg-config must be installed.  Install now (y/n)? " ).to_lowercase.begins_with('y'))
          local cmd = @|brew install pkg-config
          println cmd
          if (0 != System.run(cmd))
            throw Error( "Failed to install pkg-config." )
          endIf
        else
          throw Error( "Missing required dependency 'pkg-config'." )
        endIf
      endIf

    method configure_linux
      if (0 != System.run("which apt-get > /dev/null 2>&1"))
        if (0 == System.run("which yum > /dev/null 2>&1"))
          package_manager = "yum"
          package_manager_install = "sudo yum install"
          package_manager_list    = "rpm -ql"
        endIf
      endIf

      if (0 != System.run("which pkg-config > /dev/null 2>&1"))
        require_command_line
        if (Console.input( "pkg-config must be installed.  Install now (y/n)? " ).to_lowercase.begins_with('y'))
          local cmd = package_manager_install + " pkg-config"
          println cmd
          if (0 != System.run(cmd))
            throw Error( "Failed to install pkg-config." )
          endIf
        else
          throw Error( "Missing required dependency 'pkg-config'." )
        endIf
      endIf

    method install_library( library:Value )
      local lib = cache//library_flags[ library//name ]
      if (lib)
        # Make sure each filepath actually exists
        block lib = lib->String
          local parts = String[]
          local i = locate_nonescaped_space( lib )
          while (i)
            local part = lib.leftmost( i.value )
            if (String.exists(part)) parts.add( part )
            lib .= from( i.value+1 )
            i = locate_nonescaped_space( lib )
          endWhile
          if (String.exists(lib)) parts.add( lib )

          contingent
            forEach (part in parts)
              part .= after_any( "-I" )
              necessary (File(part).exists)
            endForEach
          satisfied
            return
          endContingent
        endBlock
      endIf

      which (System.os)
        case "macOS"
          install_macos_library( library )
        case "Linux"
          install_linux_library( library )
        others
          throw Error( ''Rogo does not know how to install a $ library.'' (System.os) )
      endWhich

    method locate_nonescaped_space( st:String )->Int32?
      local skip = false
      forEach (ch at index in st)
        if (skip)
          skip = false
        else
          which (ch)
            case '\\': skip = true
            case ' ':  return index
          endWhich
        endIf
      endForEach

      return null

    method run( cmd:String )->String
      println( cmd )
      local result = Process.run( cmd, &env )
      if (result.exit_code != 0) return null
      return result.output_string.trimmed

    method find_macos_library( library:Value )->Logical
      local name = library//name->String

      # If an 'exe' name or is specified, that executable must exist.
      if local exe = library//exe->String
        if (not System.find_executable(exe)) return false
        if (not cache//library_flags) cache//library_flags = @{}
        cache//library_flags[name] = ""
        save_cache
      endIf

      # If an 'exists-cmd' is given, it must execute without error.
      if local exists_cmd = library["exists-cmd"]->String
        if (not run(exists_cmd)) return false
      endIf

      # Find flags using 'flags', 'info' name, 'info-cmd', 'package' name, or 'name', in that order
      local flags = library//flags->String
      if (not flags)
        flags = fetch_macos_info( library["info"] )
        if (not flags and library.contains("info-cmd"))
          flags = run(library["info-cmd"])
          if (not flags) throw Error( "Error executing library info command: $"(library["info-cmd"]) )
        endIf
        if (not flags) flags = fetch_macos_info( library["package"] )
        if (not flags) flags = fetch_macos_info( name )
      endIf

      if (flags)
        println "  Library flags: $" (flags)
        if (not cache//library_flags) cache//library_flags = @{}
        cache//library_flags[name] = flags
        save_cache
        return true
      endIf

      # Check for an executable using the package name
      if local exe = library//package->String
        if (System.find_executable(exe))
          if (not cache//library_flags) cache//library_flags = @{}
          cache//library_flags[name] = ""
          save_cache
          return true
        endIf
      endIf

      # Check for an executable using the library name
      if (System.find_executable(name))
        if (not cache//library_flags) cache//library_flags = @{}
        cache//library_flags[name] = ""
        save_cache
        return true
      endIf

      return false

    method fetch_macos_info( package_name:String )->String
      if (not package_name) return null

      local info = run( "  pkg-config --cflags $"(package_name) )

      local libs = run( "  pkg-config --libs-only-L $"(package_name) )
      if (libs)
        local listing = (File(libs.after_first("-L").trimmed)/"*.a").listing
        if (listing.count) libs = listing.first
      else
        local listing = run( "  brew list -v " + package_name )
        if (listing)
          local candidates = listing.split( '\n' )
          candidates.keep( $.ends_with(".a") )
          if (candidates.count) libs = candidates.first  # .a file to link in
        endIf
      endIf

      if (info or libs)
        if (not info) info = ""
        if (not libs) libs = ""
        return info.appending(libs)
      else
        return null
      endIf

    method install_macos_library( library:Value )
      local library_name = library//name->String
      println "Checking for library $..." (library_name)

      if (find_macos_library(library)) return

      # Install library
      require_command_line
      if (not Console.input( "\nLibrary '$' must be installed.  Install now (y/n)? "(library_name) ).to_lowercase.begins_with('y'))
        throw Error( "Missing required library '$'." (library_name) )
      endIf

      local install_cmd : String

      if local install_name = library//install->String
        install_cmd = "brew install $" (install_name)
      elseIf local cmd = library["install-cmd"]->String
        install_cmd = cmd
      elseIf local package_name = library//package->String
        install_cmd = "brew install $" (package_name)
      else
        install_cmd = "brew install $" (library_name)
      endIf

      run( install_cmd )  # this could succeed in principal but return non-zero with a warning, as with zlib
      if (not find_macos_library(library))
        throw Error( "Failed to install library '$'." (library_name) )
      endIf

    method find_linux_library( library:Value )->Logical
      local name = library//name->String

      # If an 'exe' name or is specified, that executable must exist.
      if local exe = library//exe->String
        if (not System.find_executable(exe)) return false
        if (not cache//library_flags) cache//library_flags = @{}
        cache//library_flags[name] = ""
        save_cache
      endIf

      # If an 'exists-cmd' is given, it must execute without error.
      if local exists_cmd = library["exists-cmd"]->String
        if (not run(exists_cmd)) return false
      endIf

      # Find flags using 'flags', 'info' name, 'info-cmd', 'package' name, or 'name', in that order
      local flags = library//flags->String
      if (not flags)
        flags = fetch_linux_info( library["info"] )
        if (not flags and library.contains("info-cmd"))
          flags = run(library["info-cmd"])
          if (not flags) throw Error( "Error executing library info command: $"(library["info-cmd"]) )
        endIf
        if (not flags) flags = fetch_linux_info( library["package"] )
        if (not flags) flags = fetch_linux_info( name )
      endIf

      if (flags)
        println "  Library flags: $" (flags)
        if (not cache//library_flags) cache//library_flags = @{}
        cache//library_flags[name] = flags
        save_cache
        return true
      endIf

      # Check for an executable using the package name
      if local exe = library//package->String
        if (System.find_executable(exe))
          if (not cache//library_flags) cache//library_flags = @{}
          cache//library_flags[name] = ""
          save_cache
          return true
        endIf
      endIf

      # Check for an executable using the library name
      if (System.find_executable(name))
        if (not cache//library_flags) cache//library_flags = @{}
        cache//library_flags[name] = ""
        save_cache
        return true
      endIf

      return false

    method fetch_linux_info( package_name:String )->String
      if (not package_name) return null

      local info = run( "  pkg-config --cflags $"(package_name) )
      if (info) return info

      # Try rpm -ql for Yum+RPM Linux
      if (not info and package_manager_list)
        println "  Not found with pkg-config; checking with rpm..."
        local result = run( "  $ $" (package_manager_list,package_name) )
        if (result)
          println "  Located"
          return "" # TODO: check result of rpm -ql
        endIf
      endIf

      return null

    method install_linux_library( library:Value )
      local library_name = library//name->String
      println "Checking for library $..." (library//name->String)

      if (find_linux_library(library)) return

      # Install library
      require_command_line
      if (not Console.input( "\nLibrary '$' must be installed.  Install now (y/n)? "(library_name) ).to_lowercase.begins_with('y'))
        throw Error( "Missing required library '$'." (library_name) )
      endIf

      local install_cmd : String

      if local install_name = library//install->String
        install_cmd = "$ $" (package_manager_install,install_name)
      elseIf local cmd = library["install-cmd"]->String
        install_cmd = cmd
      elseIf local package_name = library//package->String
        install_cmd = "$ $" (package_manager_install,package_name)
      else
        install_cmd = "$ $" (package_manager_install,library_name)
      endIf

      run( install_cmd )  # this could succeed in principal but return non-zero with a warning, as with zlib
      if (not find_linux_library(library))
        throw Error( "Failed to install library '$'." (library_name) )
      endIf

    method library_flags( library:Value )->String
      if (not cache//library_flags.contains(library//name))
        install_library( library )
      endIf

      return cache//library_flags[library//name]->String

    method scan_autodoc( file:File )
      local cmd : String
      use builder = StringPool
        forEach (line in LineReader(file))
          line .= trimmed
          if (line.begins_with("routine rogo_"))
            cmd = line.after_first('_').before_first('(').before_first(' ')
            builder.clear
          elseIf (line.begins_with("routine description"))
            found_description_routine = true
            cmd = null
            builder.clear
          elseIf (cmd)
            if (line.begins_with('#'))
              line = line.unleft(1).trimmed
              if (line.begins_with("syntax:",&ignore_case))
                line = line.unleft(7).trimmed
                if (line.begins_with("rogo ")) line = line.unleft(5).trimmed
                syntax_info[cmd] = line
              elseIf (builder.count > 0)
                builder.println
                builder.print line
              elseIf (line != "")
                builder.print line
              endIf
            else
              # end of autodoc commment
              if (builder.count)
                local doc = builder.cloned
                local lines = doc.split('\n')
                local curln : String
                forEach (nextln in rewriter=lines.rewriter)
                  if (nextln == "")
                    if (curln)
                      rewriter.write( curln )
                      rewriter.write( "" )
                      curln = null
                    endIf
                  elseIf (curln)
                    if (curln.last != ' ') curln += ' '
                    curln += nextln
                  else
                    curln = nextln
                  endIf
                endForEach
                if (curln) lines.add( curln )
                description_info[cmd] = lines.join('\n')
              endIf
              cmd = null
            endIf
          endIf
        endForEach
      endUse

    method collect_dependencies( file:File, dependencies:Set<<String>> )
      if (not file.exists) return

      forEach (line in LineReader(file))
        line .= trimmed
        if (line.begins_with("#$"))
          local cmd = line.rightmost( -2 )
          local args = cmd.after_first( "=" ).trimmed
          cmd = cmd.before_first( "=" ).trimmed.to_lowercase

          local base_cmd = cmd.before_first('(')
          which (base_cmd)
            case "dependencies"
              if (dependencies)
                if (args.begins_with('"'))      args = args.after_first('"').before_last('"')
                elseIf (args.begins_with('\'')) args = args.after_first('\'').before_last('\'')
                dependencies.add( args )
                is_cache_modified = true
              endIf
          endWhich
        endIf

      endForEach

    method collect_directives( file:File, dependencies=null:Set<<String>> )
      if (not file.exists) return

      forEach (line at line_index in LineReader(file))
        if (line.begins_with("#$"))
          local cmd = line.rightmost( -2 )
          local args = cmd.after_first( "=" ).trimmed
          cmd = cmd.before_first( "=" ).trimmed.to_lowercase

          local base_cmd = cmd.before_first('(')
          which (base_cmd)
            case "config", "roguec"
              if (args.begins_with('"')) args = args.after_first('"').before_last('"')
              elseIf (args.begins_with('\'')) args = args.after_first('\'').before_last('\'')
              config[ cmd ] = args

            case "libraries"
              if (args.count)
                local scanner = Scanner(args)
                scanner.consume_spaces
                while (scanner.has_another)
                  if (not scanner.next_is_identifier and not scanner.next_is_string)
                    error( file, line_index+1, "Identifier expected, found '$'."(scanner.peek) )
                  endIf
                  local name = which{scanner.next_is_identifier:scanner.scan_identifier("-") || scanner.scan_string}
                  local entry = @{ name:name, link_libs:link_libraries }
                  if (config[cmd]) config[cmd].add( entry )
                  else             config[cmd] = @[entry]
                  scanner.consume_spaces

                  if (scanner.consume('('))
                    scanner.consume_spaces
                    while (scanner.has_another and not scanner.next_is(')'))
                      if (not scanner.next_is_identifier and not scanner.next_is_string)
                        error( file, line_index+1, "Identifier expected, found '$'."(scanner.peek) )
                      endIf
                      local key   = which{scanner.next_is_identifier:scanner.scan_identifier("-") || scanner.scan_string}
                      local value : Value
                      scanner.consume_spaces
                      if (scanner.consume(':'))
                        scanner.consume_spaces
                        if (scanner.next_is_string)             value = scanner.scan_string
                        elseIf (not scanner.next_is_identifier) error( file, line_index+1, "Identifier expected, found '$'."(scanner.peek) )
                        else                                    value = scanner.scan_identifier("-")
                      else
                        # An identifier with no mapped value is treated as the package name
                        value = key
                        key = "package"
                      endIf

                      contingent
                        sufficient (key == "exe")
                        sufficient (key == "exists-cmd")
                        sufficient (key == "flags")
                        sufficient (key == "info")
                        sufficient (key == "info-cmd")
                        sufficient (key == "install")
                        sufficient (key == "install-cmd")
                        sufficient (key == "package")
                        error( file, line_index+1, "Invalid library option. Supported options are exe, exists-cmd, flags, info, info-cmd, install, install-cmd, and package." )
                      endContingent

                      entry[key] = value

                      scanner.consume_spaces
                      scanner.consume( ',' )
                      scanner.consume_spaces
                    endWhile
                    if (not scanner.consume(')')) error( file, scanner.line, "Closing ')' expected." )
                  endIf
                  scanner.consume_spaces

                endWhile
              endIf

            case "dependencies"
              if (dependencies)
                if (args.begins_with('"'))      args = args.after_first('"').before_last('"')
                elseIf (args.begins_with('\'')) args = args.after_first('\'').before_last('\'')
                dependencies.add( args )
                is_cache_modified = true
              endIf

            others
              if (base_cmd == "link")
                if (cmd == "link" or cmd == "link($)" (System.os.to_lowercase))
                  if (config[cmd]?) config[cmd] += " " + args
                  else              config[cmd] = args
                endIf

              elseIf (base_cmd == "link_libs")
                if (cmd == "link_libs" or cmd == "link_libs($)" (System.os.to_lowercase))
                  if (args == "true" or args == "false")
                    link_libraries = (args == "true")
                  else
                    link_libraries = true
                  endIf
                endIf

              else
                # Join into single space-separated string
                if (config.contains(cmd))
                  config[ cmd ] = "$ $" (config[ cmd ],args)
                else
                  config[ cmd ] = args
                endIf
              endIf

          endWhich
        endIf
      endForEach

    method error( file:File, line:Int32, message:String )
      error.println "=" * 80
      error.println ''ERROR in "$" line $''(file,line)
      error.println
      error.println message
      error.println "=" * 80
      System.exit 1

    method scan_and_rewrite( file:File, &write_autodoc )
      if (not file.exists) return

      local outfile = File("$/$"(rogo_folder,file.filename))
      local writer = outfile.print_writer

      forEach (line in LineReader(file))
        local dollar = line.locate( '$' )
        while (dollar.exists)
          if (line.contains_at("$LIBRARY_FLAGS(",dollar.value))
            local close_paren = line.locate( ')', dollar.value + 1 )
            if (close_paren.exists)
              local replacement = ""
              forEach (library_name in line.from(dollar.value,close_paren.value-1).after_first('(').split(','))
                library_name = library_name.trimmed
                block
                  forEach (lib in config//libraries)
                    if (lib//name == library_name)
                      if (replacement.count > 0) replacement += " "
                      replacement += library_flags( lib )
                      escapeBlock
                    endIf
                  endForEach
                endBlock
              endForEach
              line = "$$$" (line.before(dollar.value),replacement,line.after(close_paren.value))
            endIf
          elseIf (line.contains_at("$LIBRARY_FLAGS",dollar.value))
            local replacement = ""
            forEach (lib in config//libraries)
              replacement .= appending( library_flags(lib) )
            endForEach
            line = line.replacing_at( dollar.value, 14, replacement )
          endIf
          dollar = line.locate( '$', dollar.value+1 )
        endWhile
        writer.println( line )
      endForEach

      if (write_autodoc and found_description_routine)
        writer.println @|
                        |augment Build
                        |  METHODS
                        |    method launch [insert]
        writer.indent += 6
        forEach (entry in syntax_info.entries)
          writer.println ''syntax( "$", "$" )'' (entry.key,entry.value.to_escaped_ascii('"'))
        endForEach
        forEach (entry in description_info.entries)
          writer.println ''description( "$", "$" )'' (entry.key,entry.value.to_escaped_ascii('"'))
        endForEach
        writer.indent -= 6
        writer.println @|endAugment
      endIf

      writer.close

endClass

class Buildfiles : String[]
  PROPERTIES
    pwd = File(".").abs/"" : String

  METHODS
    method add( file:File )
      file = file.resolved.abs
      if (file.filepath.begins_with(pwd)) file = File(file.filepath.unleft(pwd.count))
      if (not file.exists) return
      if (file.is_folder) return
      if (not this.contains(file.filepath)) prior.add( file.filepath )

    method add( filepath:String )
      add( File(filepath) )

    method any_newer_than( file:File )->Logical
      file = file.resolved
      forEach (cur in this)
        if (File(cur).is_newer_than(file)) return true
      endForEach
      return false

    method any_newer_than( filepath:String )->Logical
      return any_newer_than( File(filepath) )

    method contains( file:File )->Logical
      return prior.contains( file.resolved.abs.filepath )

    method contains( filepath:String )->Logical
      return contains( File(filepath) )

endClass
