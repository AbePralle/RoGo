#================================================================================
# Rogo.rogue
#================================================================================

$define VERSION "2.0"
$define DATE    "July 15, 2022"

$include CreateBuildfile
$include CreateGitIgnore
$include CreateProjectSource

#$ ROGUEC       = roguec
#$ ROGUEC_ARGS  = --whatever
#$ CC           = gcc -Wall
#$ CC_ARGS      = -a -b -c
#$ LINK         = -lalpha -lbeta    # Includes these additional flags when linking the buildfile.
#$ LINK_LIBS    = true              # Links following LIBRARIES with this Build file
#$ LINK_LIBS    = false             # Linking turned off for following LIBRARIES
#$ LIBRARIES    = libalpha
#$ LIBRARIES    = libbeta(library-name)
#$ LIBRARIES    = libfreetype6-dev(freetype2)
#$ DEPENDENCIES = Library/Rogue/**/*.rogue

#$ LIBRARIES    = name(package)
#$ LIBRARIES    = name(package:<package> install:<install-cmd> link:<link-flags> which:<which-name>)

# Build.rogue source replacements - the libraries should also be declared in #$ LIBRARIES:
#   $LIBRARY_FLAGS(lib1,lib2) -> -Ipath/to/lib1/include -Lpath/to/lib1/library -I ...

Rogo

class Rogo [singleton]
  PROPERTIES
    buildfiles        = Buildfiles()
    resolved_args     = String[]
    project_folder    : File
    rogo_folder       : File
    cache_file        : File
    cache             : Value
    config            : Value
    is_cache_modified : Logical
    link_libraries   = false
    syntax_info      = [String:String]
    description_info = [String:String]

    package_manager         = "apt"  # Linux
    package_manager_install = "sudo apt-get install"
    package_manager_list    : String

    found_description_routine : Logical

  METHODS
    method init
      local args = System.command_line_arguments
      if (args.count == 1 and args.first == "--version")
        println VERSION
        println "$ by Abe Pralle"(DATE)
        System.exit
      endIf

      local should_create_buildfile = false
      local build_filepath : String

      forEach (arg in args)
        if (arg == "--build" or arg.begins_with("--build="))
          local cur_buildfile = arg.after_first( '=' )
          if (cur_buildfile.count == 0)
            Global.error.println ''ERROR: expected filename after "--build=".''
            System.exit 1
          endIf
          if (not File(cur_buildfile).exists)
            if (File(cur_buildfile + ".rogue").exists)
              cur_buildfile += ".rogue"
            else
              Global.error.println ''ERROR: no such file "$".'' (cur_buildfile)
              System.exit 1
            endIf
          endIf
          build_filepath = File(cur_buildfile).abs
          buildfiles.add( build_filepath )

        else
          if (arg == "--create") should_create_buildfile = true
          else                   resolved_args.add( arg )
        endIf
      endForEach

      if (build_filepath)
        project_folder = File(build_filepath)
        if (not project_folder.is_folder)
          project_folder .= parent
        endIf
        rogo_folder = project_folder/".rogo"
        local pwd = (File(".").abs/"").filepath
        if (rogo_folder.filepath.begins_with(pwd)) rogo_folder = File( rogo_folder.filepath.unleft(pwd.count) )
      else
        project_folder = File(".")
        rogo_folder = File(".rogo")
      endIf

      # These add()s only succeed for files that actually exist.
      buildfiles.add( project_folder/"Build.rogue" )
      buildfiles.add( project_folder/"BuildCore.rogue" )
      buildfiles.add( project_folder/"BuildLocal.rogue" )

      if (not buildfiles.count)
        if (should_create_buildfile)
          CreateBuildfile( resolved_args )
          resolved_args.clear
        else
          local w = Console.width.or_smaller( 80 )
          Global.error.println "=" * w
          local mesg = "ROGO ERROR\n\n"
          mesg += @|No standard build file exists (Build.rogue, BuildCore.rogue, BuildLocal.rogue)
          mesg += @| and no alternate specified with --build=<filename>.
                   |
                   |
          mesg += @|Type 'rogo --create [options]' to create Build.rogue with a default framework.
                   |
                   |OPTIONS
                   |  --project=ProjectName
                   |    Creates additional starter framework for the specified ProjectName.
                   |
                   |  --bitmap
                   |    Links Build.rogue and the starter project (if --project is specified) with
                   |    libpng and libjpeg libraries.
                   |
                   |If no options are specified then only Build.rogue is created.
          Global.error.println( mesg.word_wrapped(w) )
          Global.error.println "=" * w
          Global.error.println
          System.exit 1
        endIf
      endIf

      rogo_folder.create_folder
      cache_file = "$/Cache-$.json" (rogo_folder,System.os)
      config     = @{ roguec:"roguec", filepath:cache_file.filepath }
      cache      = JSON.load( cache_file )

      if (System.is_windows)
        config//cc = "cl /EHsc /nologo"
      else
        config//cc = "gcc -Wall"
      endIf

      local base_name = rogo_folder/"Build"
      local exe       = base_name
      if (System.is_windows) exe += ".exe"           # .rogo/Build.exe
      else                   exe += "-" + System.os  # .rogo/Build-macOS (etc.)

      configure_os

      local needs_recompile = buildfiles.any_newer_than( exe )

      block
        # Process DEPENDENCIES
        local dependencies = Set<<String>>()
        collect_dependencies( File(forEach in buildfiles), dependencies )

        forEach (pattern in dependencies.values)
          local listing = File( pattern ).listing( &files )
          forEach (dependency in listing)
            if (File(dependency).filename.begins_with("Build") and not buildfiles.contains(dependency))
              collect_directives( File(dependency), dependencies )
            endIf
          endForEach
        endForEach

        forEach (pattern in dependencies.values)
          local listing = File( pattern ).listing( &files )
          forEach (dependency in listing)
            if (File(dependency).is_newer_than(exe))
              needs_recompile = true
              escapeBlock
            endIf
          endForEach
        endForEach
      endBlock

      if (needs_recompile)
        println "Recompiling $..." (File(buildfiles.first).filename)

        # Collect info for config
        collect_directives( File(forEach in buildfiles) )

        # Select ROGUEC(macOS) or ROGUEC(Linux) etc. based on the OS and merge into to ROGUEC, etc.
        local os_arg = "($)" (System.os.to_lowercase)
        local os_arg_plus_package_manager = "($-$)" (System.os.to_lowercase,package_manager)
        forEach (key in config.keys)
          if (key.contains(os_arg) or key.contains(os_arg_plus_package_manager))
            local generic_key = key.before_first('(')
            if (config.contains(generic_key) and generic_key != "cc" and generic_key != "roguec")
              # Merge specialized-platform keys with generic keys
              if (generic_key == "libraries")
                # Overwrite same-name libraries
                local table = @{}
                forEach (item in config[generic_key]) table[item//name] = item
                forEach (item in config[key])         table[item//name] = item
                config[ generic_key ] = table.values
              else
                # Append specialized keys to end of generic key string
                config[ generic_key ] += " " + config[key]
              endIf
            else
              config[ generic_key ] = config[ key ]
            endIf
          endIf
        endForEach

        # Now that we have the config info, rewriting to handle $+LIBRARY(name) etc. Places copies in .rogo/
        scan_autodoc( File(forEach in buildfiles) )
        forEach (file at index in buildfiles)
          scan_and_rewrite( File(file), &write_autodoc=(index==0) )
        endForEach

        local roguec = config//roguec
        if (not File(roguec).exists) roguec = "r2"  # use system default
        local roguec_args = config//roguec_args->String
        local cmd =  "$ --target=C++,Console,$" (roguec,System.os)
        forEach (filepath in buildfiles)
          cmd += " " + (rogo_folder/File(filepath).filename).esc
        endForEach
        cmd += " --api --debug --main --output=$ $" (base_name,roguec_args)
        println cmd

        if (0 != System.run(cmd))
          Global.error.println "ERROR compiling $." (rogo_folder)
          System.exit 1
        endIf

        cmd = config//cc->String
        if (config//cc_args) cmd += " " + config//cc_args
        cmd += " $.c"(base_name)

        forEach (library in config//libraries)
          install_library( library )
          if (library//link)
            cmd += " $" (library_flags(library))
          endIf
        endForEach

        cmd += " $$" (which{System.is_windows:"/Fe"||"-o "},exe)
        local link_args = config//link
        if (link_args != "") cmd += " " + link_args

        println cmd
        if (0 != System.run(cmd)) System.exit( 1 )
        File( File(exe).filename.before_last(".exe") + ".obj" ).delete
      endIf

      local exit_code = System.run( ''$ $'' (exe,resolved_args.map<<String>>( (arg)=>Rogo.prep_arg(arg) ).join(" ")) )
      System.exit( exit_code )

    method prep_arg( arg:String )->String
      # Quotes and escapes string if necessary
      if (not (arg.contains(' ') or arg.contains('"') or arg.contains('\\'))) return arg
      local quoted = String()
      quoted.print( '"' )
      forEach (ch in arg)
        which (ch)
          case '"':  quoted.print( "\\\"" )
          case '\\': quoted.print( "\\\\" )
          others:    quoted.print( ch )
        endWhich
      endForEach
      quoted.print( '"' )
      return quoted

    method require_command_line
      if (System.env["IDE"])
        throw Error( "$:$: error:Run 'make $' from the command line to install necessary libraries."...
        ($sourceFilepath,$sourceLine,which{System.env["TARGET"]||""}.to_lowercase) )
      endIf

    method save_cache
      is_cache_modified = false
      cache_file.save( cache.to_json(&formatted) )

    method configure_os
      if (System.is_macos)     configure_macos
      elseIf (System.is_linux) configure_linux

    method configure_macos
      if (0 != System.run("which brew > /dev/null 2>&1"))
        require_command_line
        if (Console.input( "\nHomebrew must be installed.  Install now (y/n)? " ).to_lowercase.begins_with('y'))
          local cmd = @|/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
          println cmd
          if (0 != System.run(cmd))
            throw Error( "Failed to install Homebrew." )
          endIf
        else
          throw Error( "Missing required dependency 'brew' (Homebrew)." )
        endIf
      endIf

      if (0 != System.run("which pkg-config > /dev/null 2>&1"))
        require_command_line
        if (Console.input( "pkg-config must be installed.  Install now (y/n)? " ).to_lowercase.begins_with('y'))
          local cmd = @|brew install pkg-config
          println cmd
          if (0 != System.run(cmd))
            throw Error( "Failed to install pkg-config." )
          endIf
        else
          throw Error( "Missing required dependency 'pkg-config'." )
        endIf
      endIf

    method configure_linux
      if (0 != System.run("which apt-get > /dev/null 2>&1"))
        if (0 == System.run("which yum > /dev/null 2>&1"))
          package_manager = "yum"
          package_manager_install = "sudo yum install"
          package_manager_list    = "rpm -ql"
        endIf
      endIf

      if (0 != System.run("which pkg-config > /dev/null 2>&1"))
        require_command_line
        if (Console.input( "pkg-config must be installed.  Install now (y/n)? " ).to_lowercase.begins_with('y'))
          local cmd = package_manager_install + " pkg-config"
          println cmd
          if (0 != System.run(cmd))
            throw Error( "Failed to install pkg-config." )
          endIf
        else
          throw Error( "Missing required dependency 'pkg-config'." )
        endIf
      endIf

    method install_library( library:Value )
      local lib = cache//library_flags[ library//name ]
      if (lib)
        # Make sure each filepath actually exists
        block lib = lib->String
          local parts = String[]
          local i = locate_nonescaped_space( lib )
          while (i)
            local part = lib.leftmost( i.value )
            if (String.exists(part)) parts.add( part )
            lib .= from( i.value+1 )
            i = locate_nonescaped_space( lib )
          endWhile
          if (String.exists(lib)) parts.add( lib )

          contingent
            forEach (part in parts)
              part .= after_any( "-I" )
              necessary (File(part).exists)
            endForEach
          satisfied
            return
          endContingent
        endBlock
      endIf

      which (System.os)
        case "macOS"
          install_macos_library( library )
        case "Linux"
          install_linux_library( library )
        others
          throw Error( ''Rogo does not know how to install a $ library.'' (System.os) )
      endWhich

    method locate_nonescaped_space( st:String )->Int32?
      local skip = false
      forEach (ch at index in st)
        if (skip)
          skip = false
        else
          which (ch)
            case '\\': skip = true
            case ' ':  return index
          endWhich
        endIf
      endForEach

      return null

    method run( cmd:String )->String
      println( cmd )
      local result = Process.run( cmd, &env )
      if (result.exit_code != 0) return null
      return result.output_string.trimmed

    method find_macos_library( library:Value )->Logical
      local name = library//name->String
      local package = library//package->String

      local result = run( "  pkg-config --cflags " + package )
      if (result)
        local flags = String[]

        # cflags
        flags.add( result )

        # library( link:... ) flags
        if (library//link and not library//link.is_logical)
          # If the link flags are more than just 'true'.
          flags.add( library//link )
        endIf

        # static library path
        local candidates : String[]
        result = run( "  pkg-config --libs-only-L " + package )
        if (result and result.begins_with("-L"))
          candidates = File( result.from(2) ).listing
        else
          result = run( "  brew list -v " + name )
          if (result)
            candidates = result.split( '\n' )
          endIf
        endIf

        if (candidates)
          candidates.keep( $.ends_with(".a") )
          if (candidates.count) flags.add( candidates.first )  # .a file to link in
        else
          return false
        endIf

        local all_flags = flags.join( ' ' )
        println "  Library flags: $" (all_flags)
        if (not cache//library_flags) cache//library_flags = @{}
        cache//library_flags[name] = all_flags
        save_cache
        return true
      endIf

      # "Library" may be executable package - use 'which' to check.
      println "  which " + library["which"]
      if (0 == System.run("which $ > /dev/null 2>&1"(library["which"])))
        local flags = which{ library//link || Value("") }
        if (flags != "") println "  Library flags: $" (flags)
        if (not cache//library_flags) cache//library_flags = @{}
        cache//library_flags[name] = flags
        save_cache
        return true
      endIf

      return false

    method install_macos_library( library:Value )
      local library_name = library//name->String
      println "Checking for library $..." (library_name)

      if (not find_macos_library(library))
        # Install library
        require_command_line
        if (not Console.input( "\nLibrary '$' must be installed.  Install now (y/n)? "(library_name) ).to_lowercase.begins_with('y'))
          throw Error( "Missing required library '$'." (library_name) )
        endIf

        # Two install options:
        #   libname                 - install libname
        #   libname(install:"cmd")  - install cmd
        local install_cmd = library//name
        if (library.contains("install")) install_cmd = library//install

        run( "brew install $" (install_cmd) )  # this could succeed in principal but return non-zero with a warning, as with zlib
        if (not find_macos_library(library))
          throw Error( "Failed to install library '$'." (library_name) )
        endIf
      endIf

    method find_linux_library( library:Value )->Logical
      local name = library//name->String
      local package = library//package->String

      # Try pkg-config first
      local result = run( "  pkg-config --cflags --libs " + package )
      if (result)
        local flags = result
        println "  Library flags: $" (flags)
        if (not cache//library_flags) cache//library_flags = @{}
        cache//library_flags[name] = flags
        save_cache
        return true
      endIf

      # Next try rpm -ql for Yum+RPM Linux
      if (package_manager_list)
        println "  No found with pkg-config; checking with rpm"
        result = run( "  $ $" (package_manager_list,package) )
        if (result)
          println "  Located"
          if (not cache//library_flags) cache//library_flags = @{}
          cache//library_flags[name] = "" # library exists but has no flags
          save_cache
          return true
        endIf
      endIf

      # "Library" may be executable package - use 'which' to check.
      println "  which " + library["which"]
      if (0 == System.run("which $ > /dev/null 2>&1"(library["which"])))
        if (not cache//library_flags) cache//library_flags = @{}
        cache//library_flags[name] = "" # library exists but has no flags
        save_cache
        return true
      endIf

      return false

    method install_linux_library( library:Value )
      local library_name = library//name->String

      println "Checking for library $..." (library//name->String)

      if (not find_linux_library(library))
        # Install library
        require_command_line
        if (not Console.input( "\nLibrary '$' must be installed.  Install now (y/n)? "(library_name) ).to_lowercase.begins_with('y'))
          throw Error( "Missing required library '$'." (library_name) )
        endIf

        # Two install options:
        #   libname                 - install libname
        #   libname(install:"cmd")  - install cmd
        local install_cmd = library//name
        if (library.contains("install")) install_cmd = library//install

        local cmd = "$ $" (package_manager_install,install_cmd)
        print "> "
        println cmd
        if (System.run(cmd) or not find_linux_library(library))
          throw Error( "Failed to install library '$'." (library_name) )
        endIf
      endIf

    method library_flags( library:Value )->String
      if (not cache//library_flags.contains(library//name))
        install_library( library )
      endIf

      return cache//library_flags[library//name]->String

    method scan_autodoc( file:File )
      local cmd : String
      use builder = StringPool
        forEach (line in LineReader(file))
          line .= trimmed
          if (line.begins_with("routine rogo_"))
            cmd = line.after_first('_').before_first('(').before_first(' ')
            builder.clear
          elseIf (line.begins_with("routine description"))
            found_description_routine = true
            cmd = null
            builder.clear
          elseIf (cmd)
            if (line.begins_with('#'))
              line = line.unleft(1).trimmed
              if (line.begins_with("syntax:",&ignore_case))
                line = line.unleft(7).trimmed
                if (line.begins_with("rogo ")) line = line.unleft(5).trimmed
                syntax_info[cmd] = line
              elseIf (builder.count > 0)
                builder.println
                builder.print line
              elseIf (line != "")
                builder.print line
              endIf
            else
              # end of autodoc commment
              if (builder.count)
                local doc = builder.cloned
                local lines = doc.split('\n')
                local curln : String
                forEach (nextln in rewriter=lines.rewriter)
                  if (nextln == "")
                    if (curln)
                      rewriter.write( curln )
                      rewriter.write( "" )
                      curln = null
                    endIf
                  elseIf (curln)
                    if (curln.last != ' ') curln += ' '
                    curln += nextln
                  else
                    curln = nextln
                  endIf
                endForEach
                if (curln) lines.add( curln )
                description_info[cmd] = lines.join('\n')
              endIf
              cmd = null
            endIf
          endIf
        endForEach
      endUse

    method collect_dependencies( file:File, dependencies:Set<<String>> )
      if (not file.exists) return

      forEach (line in LineReader(file))
        line .= trimmed
        if (line.begins_with("#$"))
          local cmd = line.rightmost( -2 )
          local args = cmd.after_first( "=" ).trimmed
          cmd = cmd.before_first( "=" ).trimmed.to_lowercase

          local base_cmd = cmd.before_first('(')
          which (base_cmd)
            case "dependencies"
              if (dependencies)
                if (args.begins_with('"'))      args = args.after_first('"').before_last('"')
                elseIf (args.begins_with('\'')) args = args.after_first('\'').before_last('\'')
                dependencies.add( args )
                is_cache_modified = true
              endIf
          endWhich
        endIf

      endForEach

    method collect_directives( file:File, dependencies=null:Set<<String>> )
      if (not file.exists) return

      forEach (line in LineReader(file))
        if (line.begins_with("#$"))
          local cmd = line.rightmost( -2 )
          local args = cmd.after_first( "=" ).trimmed
          cmd = cmd.before_first( "=" ).trimmed.to_lowercase

          local base_cmd = cmd.before_first('(')
          which (base_cmd)
            case "config", "roguec"
              if (args.begins_with('"')) args = args.after_first('"').before_last('"')
              elseIf (args.begins_with('\'')) args = args.after_first('\'').before_last('\'')
              config[ cmd ] = args

            case "libraries"
              if (args.count)
                local parser = JSONParser( Scanner(args) )
                parser.consume_spaces
                while (parser.has_another)
                  local name = parse_filepath( parser )
                  local entry = @{ name:name, link:link_libraries }
                  if (config[cmd]) config[cmd].add( entry )
                  else             config[cmd] = @[]
                  parser.consume_spaces
                  entry//package = name.before_first( "-dev" )  # default of e.g. libpng-dev is libpng
                  entry["which"] = name
                  if (parser.consume('('))
                    parser.consume_spaces
                    while (parser.has_another)
                      if (parser.consume(')')) escapeWhile
                      local key = parser.parse_identifier
                      parser.consume_spaces
                      if (parser.consume(':'))
                        parser.consume_spaces
                        local value = parse_filepath( parser )
                        entry[ key ] = value
                      else
                        # An identifier with no mapped value is treated as the package name
                        entry//package = key
                      endIf
                      parser.consume_spaces
                      parser.consume( ',' )
                      parser.consume_spaces
                    endWhile
                  endIf
                  parser.consume_spaces
                endWhile
              endIf

            case "dependencies"
              if (dependencies)
                if (args.begins_with('"'))      args = args.after_first('"').before_last('"')
                elseIf (args.begins_with('\'')) args = args.after_first('\'').before_last('\'')
                dependencies.add( args )
                is_cache_modified = true
              endIf

            others
              if (base_cmd == "link")
                if (cmd == "link" or cmd == "link($)" (System.os.to_lowercase))
                  if (config[cmd]?) config[cmd] += " " + args
                  else              config[cmd] = args
                endIf

              elseIf (base_cmd == "link_libs")
                if (cmd == "link_libs" or cmd == "link_libs($)" (System.os.to_lowercase))
                  if (args == "true" or args == "false")
                    link_libraries = (args == "true")
                  else
                    link_libraries = true
                  endIf
                endIf

              else
                # Join into single space-separated string
                if (config.contains(cmd))
                  config[ cmd ] = "$ $" (config[ cmd ],args)
                else
                  config[ cmd ] = args
                endIf
              endIf

          endWhich
        endIf
      endForEach

    method scan_and_rewrite( file:File, &write_autodoc )
      if (not file.exists) return

      local outfile = File("$/$"(rogo_folder,file.filename))
      local writer = outfile.print_writer

      forEach (line in LineReader(file))
        local dollar = line.locate( '$' )
        while (dollar.exists)
          if (line.contains_at("$LIBRARY_FLAGS(",dollar.value))
            local close_paren = line.locate( ')', dollar.value + 1 )
            if (close_paren.exists)
              local replacement = ""
              forEach (library_name in line.from(dollar.value,close_paren.value-1).after_first('(').split(','))
                library_name = library_name.trimmed
                block
                  forEach (lib in config//libraries)
                    if (lib//name == library_name)
                      if (replacement.count > 0) replacement += " "
                      replacement += library_flags( lib )
                      escapeBlock
                    endIf
                  endForEach
                endBlock
              endForEach
              line = "$$$" (line.before(dollar.value),replacement,line.after(close_paren.value))
            endIf
          endIf
          dollar = line.locate( '$', dollar.value+1 )
        endWhile
        writer.println( line )
      endForEach

      if (write_autodoc and found_description_routine)
        writer.println @|
                        |augment Build
                        |  METHODS
                        |    method launch [insert]
        writer.indent += 6
        forEach (entry in syntax_info.entries)
          writer.println ''syntax( "$", "$" )'' (entry.key,entry.value.to_escaped_ascii('"'))
        endForEach
        forEach (entry in description_info.entries)
          writer.println ''description( "$", "$" )'' (entry.key,entry.value.to_escaped_ascii('"'))
        endForEach
        writer.indent -= 6
        writer.println @|endAugment
      endIf

      writer.close

    method parse_filepath( parser:JSONParser )->String
      if (parser.next_is('"')) return parser.parse_string

      local buffer = String()
      while (parser.has_another and not " \n()".contains(parser.peek)) buffer.print( parser.read )

      if (buffer.count == 0) buffer.print( parser.read )

      return buffer

endClass

class Buildfiles : String[]
  PROPERTIES
    pwd = File(".").abs/"" : String

  METHODS
    method add( file:File )
      file = file.resolved.abs
      if (file.filepath.begins_with(pwd)) file = File(file.filepath.unleft(pwd.count))
      if (not file.exists) return
      if (file.is_folder) return
      if (not this.contains(file.filepath)) prior.add( file.filepath )

    method add( filepath:String )
      add( File(filepath) )

    method any_newer_than( file:File )->Logical
      file = file.resolved
      forEach (cur in this)
        if (File(cur).is_newer_than(file)) return true
      endForEach
      return false

    method any_newer_than( filepath:String )->Logical
      return any_newer_than( File(filepath) )

    method contains( file:File )->Logical
      return prior.contains( file.resolved.abs.filepath )

    method contains( filepath:String )->Logical
      return contains( File(filepath) )

endClass
